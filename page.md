# 摘要



# ABSTRACT



# 第1章  绪论

## 1.1  课题来源

自拟课题

## 1.2  课题背景

​        如今网络和5G迅速发展，我们已经来到了“互联网+”的万物互联时代。通过公众调查得知，社会中年轻群体对于互联网的依赖程度是最深的，大学生和都市白领工作者每天对于互联网的使用率达到了100%。他们主要使用互联网进行实时新闻的获取、搜索和学习自己想要的知识以及和自己的伙伴保持沟通交流，甚至平常的衣物、视频的购买和游戏休闲也是在网络中完成。截至2018年，我国网民规则已经到达8.026亿人，已经成为了一个互联网大国。

​        随着互联网的发展伴随而来的就是大量的攻击和漏洞利用，以前的黑客使用简单的一句话木马就可以拿下Web网站的权限，而用来检测它们的方式仅仅是原始的正则表达式。

​        在如今的高级攻防演练中，Webshell的混淆和复杂程度发生了很大的变化。从最初的一句话木马到现在的混淆样本、无文件落地的内存马技术，Webshell技术可以说是日新月异，但是检测技术通常还是依赖于正则表达式去进行敏感匹配。根据表1.1可以看出，当前PHP还是Web网站的首选语言，如果能有效的检测出Web网站中存在的Webshell，可以极大的降低网站数据泄露与被攻击者控制的概率，对企业和Web管理员来说是非常有意义的。

<center><strong>表1.1  Web网站使用语言份额图（%）</strong></center>

|    | 2016 | 2017 | 2018 | 2019 | 2020 | 2021 |
| ---- | ------- | ----- | ------- | ----- | --------- | ---- |
| PHP | 80.0%   | 80.0%  | 80.2%    | 78.9%  | 79.1%      | 78.8% |
| Java | 3.1%   | 3.3%  | 3.4%    | 4.0%  | 3.7%      | 3.6% |
| Python | 1.7%   | 1.6%  | 1.3%    | 1.1%  | 1.3%      | 1.4% |
| ASP.NET | 15.6%   | 14.8%  | 13.5%    | 11.8%  | 10.6%      | 9.3% |

## 1.3  国内外在该方向的研究现状及分析

### 1.3.1  国外研究现状

​        相较于国内各个厂商还在探索的状态，国外的检测技术已经相对成熟了。伴随Windows的检测工具Windows Defender和强力的杀软例如卡巴斯基(kaspersky)、迈克菲(McAfee)等，他们都有着强大的检测技术。VirusTotal团队在七年前就已经推出了Yara语言，用来检测敏感的数据和文本，他提供的字符串查找、程序入口点偏移、模糊数据匹配等功能使得其仍然为当前主流的检测方式。随着网络技术的更新，静态检测、动态检测和污点分析甚至CodeQL分析也在不断地加入检测大军的行列。

### 1.3.2  国内研究现状 

​        国内的厂商陆续也推出了Webshell检测服务，其中老牌厂商当属河马查杀和D盾查杀。但是由于技术上的不足，这两款产品在面对用对抗技术和绕过技术处理过的样本时会显得非常模糊，仿佛检测本领全部失效。表1.2列举了几款国内的Webshell检测厂商的检测能力。

<center><strong>表1.2  不同厂家Webshell检测效果</strong></center>

|          | 小型木马 | 大型木马 | 混淆样本 | 变量替换样本 | 字符拆分样本 | 动态调用样本 |
| -------- | -------- | -------- | -------- | ------------ | ------------ | ------------ |
| 河马查杀 | 检出     | 检出     | 部分检出 | 部分检出     | 未检出       | 部分检出     |
| D盾查杀  | 检出     | 检出     | 部分检出 | 部分检出     | 部分检出     | 部分检出     |
| 安全狗   | 检出     | 检出     | 未检出   | 部分检出     | 未检出       | 部分检出     |
| 云盾     | 检出     | 检出     | 未检出   | 部分检出     | 未检出       | 未检出       |

## 1.4  本文的研究内容

​        随着网络安全的战略层级越来越高，网络安全局势日趋严重，及时发现Web服务中存在的Webshell并第一时间进行排查和应急响应可以极大的降低风险。同时，对于安全从业者来说，通过提高检测能力，减少误报的同时也降低了人工复审的开销。Yara语言强大的检测能力可以使我们通过简单或者定向的规则，快速而准确的筛选出可疑文件，从而提升效率，减少不必要的支出。

​        为了实现反混淆，本文的研究内容为：PHP-Parser在反混淆中的实现，尽可能覆盖当前出现的混淆手法，对发现的混淆样本进行反混淆，还原成最简的样式，然后通过Yara规则进行匹配，从而发现Webshell文件。

## 1.5  本文的创新之处

​        本文在研究过程中，通过总结以前的研究内容和绕过手法，在以下两个方面进行了改进。抛弃通过正则表达式匹配敏感字符的方式，改用约束性更强的Yara语言；不在局限于静态分析原始代码，尝试通过PHP-Parser将其转换为等价式；

## 1.6  论文的组织结构

本论文根据内容不同分为五个章节，每章的内容简要概括如下：

第1章介绍了当前Webshell检测现状和课题来源、课题研究的背景以及当前国内外研究现状和本课题的研究内容

第2章主要针对目前在高级攻防演练中使用到的混淆和对抗手段进行介绍和研究。

第3章主要介绍目前市面上厂家进行Webshell检测时运用到的检测技术，通过对这些技术的研究来为反混淆的实现打下基础

第4章主要介绍了使用PHP-Parser进行反混淆的整体架构，对反混淆工作流程的确认。按照既定的流程逐步的实现每个反混淆功能的内容，实现对混淆样本的化简转换。

第5章是本论文的总结。对实现的检测效果进行测试与评估，并且对之后检测手段的展望。



# 第2章  Webshell混淆手段研究与分析

本章将从Webshell的定义出发，详细研究混淆手段的原理

## 2.1  Webshell简介

​        webshell是web入侵的脚本攻击工具。

​        简单的说来，webshell就是一个asp或php木马后门，黑客在入侵了一个网站后，常常在将这些asp或php木马后门文件放置在网站服务器的web目录中，与正常的网页文件混在一起。然后黑客就可以用web的方式，通过asp或php木马后门控制网站服务器。一个wenshell通常含有以下功能：

**（1）站长工具**

​        Webshell被站长常常用于网站管理、服务器管理等，根据FSO权限的不同，作用有在线编辑网页脚本、上传下载文件、查看数据库、执行任意程序命令等。

**（2）持续远程访问**

​        入侵者可以利用从而达到长期控制网站服务器的目的，若攻击者自行修复了漏洞，以确保没有其他人会利用该漏洞，攻击者可以低调的随时控制服务器。一些流行的webshell使用密码验证和其他技术来确保只有上传webshell的攻击者才能访问它。（webshell密码爆破工具表示不服）

**（3）权限提升**

​        在服务器没有配置错误的情况下，webshell将在web服务器的用户权限下运行，该用户权限是有限的。通过使用webshell，攻击者可以尝试通过利用系统上的本地漏洞来执行权限提升，常见的有查找敏感配置文件、通过内核漏洞提权、利用低权限用户目录下可被Root权限用户调用的脚本提权、任务计划等（从入门到放弃）

**（4）极强的隐蔽性**

​        有些恶意网页脚本可以嵌套在正常网页中运行，且不容易被查杀。webshell还可以穿越服务器防火墙，由于与被控制的服务器或远程主机交互的数据都是通过80端口传递，因此不会被防火墙拦截，在没有记录流量的情况下，webshell使用post包发送，也不会被记录在系统日志中，只会在web日志中记录一些数据提交的记录。

## 2.2  通过动态调用的混淆

### 2.2.1  混淆敏感的变量名

​        正常情况下，PHP中调用函数采用的是函数名(参数名)的形式，但是PHP的特性允许通过变量来进行函数调用。当声明一个String型变量，该变量的值为某函数名时，可以通过在该变量后追加括号的方式来进行调用。当使用传统的正则匹配一句话木马时，通常会捕捉eval()这类的敏感语句。但是当把eval作为一个字符串赋值给一个变量时，eval()语句就被打破，正则表达式不再能够捕捉到该部分的特征。

​        例如，在某PHP文件中，存在如下语句

```php
$a = 'eval';
$cmd = "$_POST['a']";
$a($cmd);
```

​        其中，全局变量a是用户可控的输入点。当通过正则表达式`eval\(\$_POST\['[a-z]'\]\)`进行测试时，这种通过动态调用的方式就可以完美的绕过该检测方法。当用户传入的语句为"system("whoami");"时，该语句就会等价于

```php
eval(system("whoami"););
```

​        当用户传入其他恶意命令时，就会达到其他恶意目的。在PHP5之后，eval结构已经作为表达式，不能够作为函数动态调用，当在PHP5之后执行该代码，会得到如下警告"Fatal error: Uncaught Error: Call to undefined function eval()"但这不代表这种混淆方法的失效，因为eval在webshell中最为典型，除此之外的函数几乎全部支持这种动态调用的方式。

​        对于这种类型的混淆，我们可以创建一个全局的变量表。从脚本的起点开始，当遇到变量的声明语句，我们取出声明节点的Expr子节点并将其存入变量表，当遇到FunCall节点时，先判断函数名是否为变量，如果是变量则通过全局变量表取出对应值进行修改，然后在执行该表达式。

### 2.2.2  混淆敏感的字符串

​        除了混淆可能会被拦截的函数结构体，我们也可以混淆传入恶意函数中的参数。当把恶意的内容赋值给变量，然后将该变量作为参数传入恶意函数，同样可以达到执行恶意命令的效果。

​        例如，在某PHP文件中存在如下的自定义函数

```php
function e($cmd){
	eval($cmd);
}
$cmd = $_POST['a'];
e($cmd);
```

​        这里使用全局变量cmd接收数据包中接收的POST类型变量a，然后调用自定义函数进行命令执行。因为eval函数在正常的业务中也会频繁的出现，如果没有在其参数里捕获到明确的恶意行为，厂商不会将其判断为webshell，凭借这一特性，我们也轻而易举的绕过了检测。

## 2.3  通过字符串操作的混淆

### 2.3.1  从字符列表中取出敏感字符

​        在任意一门编程语言中都有这样一个特性，可以从字符串中取出特定的字符，然后将其拼接到一个字符串变量中。例如我们可以从26个字母中依次取出'e'、'v'、'a'、'l'四个字母，然后将其进行拼接，得到eval函数。PHP允许值的拼接给我们混淆和绕过带来了很大的便利，我们可以借助这一特性用不同的数据结构进行混淆。

​        例如我们可以通过数组进行混淆：

```php
$arr = ['e','v','a','l'];
$func = $arr[0].$arr[1].$arr[2].$arr[3];
$func($_POST['a']);
```

​        通过把需要的数据存入数组，然后按照一定的顺序将其取出并进行拼接，我们就可以绕过初级的检测达到攻击的目的。目前我们可以从以下几个方面进行混淆：

​        （1）通过字符替换函数得到敏感函数

​        （2）通过遍历数组取出指定的祖字符进行拼接得到敏感函数

​        （3）通过过滤指定的字符使得剩余字符刚好为敏感函数

​        对于这种类型的Webshell反混淆，可以通过对字符串节点的操作进行判断，然后依照原有的逻辑使用最终的结果替换原有的节点，但是这仅限于单纯的字符串操作，如果想$arr[0]这种类型的变量取值，则还要依靠全局的变量表进行反混淆。

### 2.3.2  通过字符串的运算取出敏感字符

​        字符之间存在着与(and)、或(or)、非(!)、异或(xor)、取反(~)等操作，通过字符之间两两的位运算，也可以得到敏感的字符串。目前流行的无字母数字Webshell运用的就是这种混淆方式，主要有两个思路：

​        （1）利用字符位运算

这是最简单、最容易想到的方法。在PHP中，两个字符串执行异或操作以后，得到的还是一个字符串。所以，我们想得到a-z中某个字母，就找到某两个非字母、数字的字符，他们的异或结果是这个字母即可。

例如，我们需要得到字符a，我们可以通过遍历字母表，然后将其两两异或的结果输出，最终可以得到'%01'^'`'的值为a，且两个字符串无任何敏感操作，可以轻而易举地绕过依靠与静态特征检测的手段。

除了字符的异或运算，还可以使用取反运算来获得需要的字符，这种方法利用的是采用UTF-8(Universal Character Set/Unicode Transformation Format)编码的某个汉字，然后将其中的某个指定编码字符取出之后进行取反。

例如，我们对‘瞰’字分析，发现其第二位字符为'\x8c'，取反之后刚好为字母s，所以我们通过尝试可以得到表2.1中的部分对应关系。

<center><strong>表2.1 字符取反对应敏感字母关系</strong></center>

| 原始字符 | 操作       | 结果 |
| -------- | ---------- | ---- |
| 瞰       | ~('瞰'{1}) | a    |
| 和       | ~('和'{2}) | s    |
| 的       | ~('的'{1}) | e    |
| 半       | ~('半'{1}) | r    |
| 始       | ~('始'{2}) | t    |

​        利用这一特性我们可以生成如下的样本

```PHP
<?php
$__=('>'>'<')+('>'>'<');
$_=$__/$__;

$____='';
$___="瞰";$____.=~($___{$_});$___="和";$____.=~($___{$__});$___="和";$____.=~($___{$__});$___="的";$____.=~($___{$_});$___="半";$____.=~($___{$_});$___="始";$____.=~($___{$__});

$_____='_';$___="俯";$_____.=~($___{$__});$___="瞰";$_____.=~($___{$__});$___="次";$_____.=~($___{$_});$___="站";$_____.=~($___{$_});

$_=$$_____;
$____($_[$__]);
```

基本没有任何的特征，这种混淆方法对于没有使用数据流分析和反混淆的检测手段来说几乎不能检出，绕过率极高。

（2）利用字符的自增运算符

在严格的假想条件下，我们希望不出现任何的字母和数字，这样的Webshell是很难被检测到的。PHP作为弱类型语言，存在一个特性，即是在处理字符串变量的算数运算时，沿用了Perl语言的习惯，而非C语言。

在Perl中，$a = 'Z';$a++; 能够把$a变成'AA'，而在C语言中，a = 'Z';a++;会把a变成'['（因为'Z'的ASCII值为90，'['的ASCII值为91）。而且字符变量只能递增，不能递减，并且只支持纯字母（a-z和A-Z）。

这个特性使得我们可以通过字母‘a’或者字母‘A’作为起始字符来构建任何我们想要的字符。

在PHP中，当数组和字符串被强制连接时，数组将被转换为一个值为‘Array’的字符串，这样一来我们就同时拿到了字符‘A’和‘a’。

依赖于上述特性，我们可以得到无字母数字的Webshell。

## 2.4  通过变量声明的混淆

在进行变量声明时，PHP允许通过函数的返回值来初始化变量。可以通过利用其他已知的混淆方式搭配变量进行二次混淆。这样我们可以把可能会被检测的特征字符通过函数变换之后赋值给变量，以此来达到绕过检测的目的。可以使用的声明手段包括但不限于如下几种：

​        （1）通过字符函数的返回值。例如“strrev('lave');”，该函数会返回eval字符串，可以作为声明条件赋值给变量，该变量的值即为eval。

​        （2）通过多元操作。因为存在字符串拼接、字符串运算的特性，可以通过多元运算操作来获取敏感函数。一个字符拼接的混淆可能如下所示，“$a = 'e'.'v'.'a'.'l';”，通过依次拼接e、v、a、l四个字符来得到eval函数。

​        （3）通过截取固定常量值的字段。PHP存在内置的常量，其中表2.2中列举的常量为经常被利用的常量。

<center><strong>表2.2 PHP部分内置常量及其含义</strong></center>

| 常量值      | 含义                   |
| ----------- | ---------------------- |
| \__FILE__   | 文件的完整路径和文件名 |
| \__CLASS__  | 类的名称               |
| \__METHOD__ | 类的方法名             |
| PHP_OS      | 运行PHP的操作系统      |
| PHP_VERSION | 运行PHP的版本号        |

​        例如：我们可以通过PHP_OS[0]的到字符‘L’，通过\__FILE__得到路径和文件名，然后通过索引取出我们需要的字符。

## 2.5  通过变量互相引用的混淆

## 2.6  通过多元运算的混淆

## 2.7  其他混淆方式

## 2.8  本章小结



# 第3章 Webshell检测手段相关研究与分析

## 3.1  正则表达式检测

## 3.2  Yara规则检测

## 3.3  静态检测

## 3.4  动态检测

## 3.5  污点追踪检测

## 3.6  本章小节

# 第4章 使用PHP-Parser进行反混淆的设计与实现

## 4.1  需求分析

## 4.2 反混淆的设计

### 4.2.1  变量声明的反混淆

### 4.2.2  函数动态调用的反混淆

### 4.2.3  字符串操作的反混淆

### 4.2.4  多元运算的反混淆

### 4.2.5  对于变量互相引用的反混淆

## 4.3  反混淆实现

### 4.3.1  变量声明反混淆实现

### 4.3.2  函数动态调用反混淆实现

### 4.3.3  字符串操作反混淆实现

### 4.3.4  多元运算反混淆实现

### 4.3.5  变量互相引用反混淆实现

## 4.4  反混淆测试

### 4.4.1  测试环境搭建

### 4.4.2  功能测试

### 4.4.3  检测性能测试

## 4.5  本章小结

# 第5章 总结与展望

## 5.1  工作总结

## 5.2  问题与展望



# 参考文献



# 致谢





